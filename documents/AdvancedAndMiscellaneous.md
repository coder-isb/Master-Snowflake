# Category 10: Advanced Features & Miscellaneous  
Deep Dive for Architects, Data Engineers & Interview Prep

Snowflake provides advanced capabilities that support automation, CDC pipelines, semi-structured data analytics, external integrations, and platform-level collaboration.  
This guide explains **Streams, Tasks, Materialized Views, Search Optimization, UDFs, External Functions, Marketplace**, and more with **scenarios, tradeoffs, and best practices**.

---

## Table of Contents

1. [Streams & Tasks (Incremental Pipelines)](#1-streams--tasks-incremental-pipelines)  
2. [Materialized Views & Search Optimization](#2-materialized-views--search-optimization)  
3. [Stored Procedures & UDFs](#3-stored-procedures--udfs)  
4. [Semi-Structured & Nested Data](#4-semi-structured--nested-data)  
5. [External Functions & Integrations](#5-external-functions--integrations)  
6. [Snowflake Marketplace & Data Exchange](#6-snowflake-marketplace--data-exchange)  
7. [Scenarios](#7-scenarios)  
8. [Tradeoffs](#8-tradeoffs)  
9. [Cost Considerations](#9-cost-considerations)  
10. [Best Practices](#10-best-practices)  

---

# 1. Streams & Tasks (Incremental Pipelines)

### Q1: What are Streams in Snowflake?  
**Answer:**  
Streams track table changes (inserts, updates, deletes) and expose only delta changes since the last consumption. They provide CDC without scanning the entire table.

### Q2: What types of Streams exist?  
**Answer:**  
- **Standard Streams** track row-level changes.  
- **Append-only Streams** capture only inserts for high-volume pipelines.  
- **Schema-change handling Streams** track structural table modifications.

### Q3: How does a Stream maintain state?  
**Answer:**  
Snowflake stores offsets in metadata tied to micro-partition lineage. State is preserved until the stream is consumed.

### Q4: What happens after a Stream is consumed?  
**Answer:**  
The Stream advances its offset, exposing only new changes on the next read.

### Q5: What are Tasks in Snowflake?  
**Answer:**  
Tasks automate SQL-based operations (e.g., ingest, transform, enrich) using scheduled or dependency-based execution.

### Q6: How do Streams & Tasks work together?  
**Answer:**  
Tasks trigger incremental pipelines that consume Streams to process only changed data.

### Q7: Why use CDC instead of full loads?  
**Answer:**  
CDC reduces cost, minimizes latency, and improves performance for large datasets.

### Q8: Can Streams track external tables?  
**Answer:**  
No. Streams track only native Snowflake tables.

### Q9: What happens if a Task fails?  
**Answer:**  
The Stream offset does not advance, ensuring idempotent reprocessing.

### Q10: Can Streams be daisy-chained?  
**Answer:**  
Yes. Downstream Streams capture changes generated by upstream transformations.

---

# 2. Materialized Views & Search Optimization

### Q11: What are Materialized Views (MVs)?  
**Answer:**  
Precomputed views that store query results physically. Snowflake refreshes MVs automatically based on table changes.

### Q12: How does Snowflake refresh MVs?  
**Answer:**  
Refreshes are incremental and metadata-based using micro-partition lineage. Only affected partitions are recomputed.

### Q13: When are Materialized Views beneficial?  
**Answer:**  
- Expensive aggregations  
- Flattened semi-structured data  
- High-frequency dashboards  
- Large joins with selective predicates  

### Q14: What is the Search Optimization Service (SOS)?  
**Answer:**  
A service that maintains specialized search indexes for efficient query filtering on sparse or selective criteria.

### Q15: When to use Search Optimization?  
**Answer:**  
- High-cardinality filtering  
- Text searches  
- Unevenly distributed micro-partitions  

### Q16: Does Search Optimization replace clustering keys?  
**Answer:**  
No. It complements clustering by accelerating highly selective predicates.

---

# 3. Stored Procedures & UDFs

### Q17: What are Snowflake Stored Procedures?  
**Answer:**  
Procedural code used to orchestrate multi-step logic, loops, branching, and error-handling.

### Q18: What languages can Stored Procedures use?  
**Answer:**  
JavaScript or Snowflake Scripting.

### Q19: What are UDFs?  
**Answer:**  
User-defined functions that encapsulate reusable logic, often for transformations or custom computations.

### Q20: What types of UDFs exist?  
**Answer:**  
- JavaScript UDFs  
- Java UDFs  
- SQL UDFs  
- Python UDFs (via Snowpark)

### Q21: When are Stored Procedures preferred over UDFs?  
**Answer:**  
For multi-step workflows, branching logic, error handling, and orchestration.

---

# 4. Semi-Structured & Nested Data

### Q22: What semi-structured formats does Snowflake support?  
**Answer:**  
JSON, XML, AVRO, ORC, Parquet.

### Q23: How is semi-structured data stored?  
**Answer:**  
Optimized binary format stored in VARIANT columns, automatically micro-partitioned.

### Q24: What is the benefit of VARIANT storage?  
**Answer:**  
Schema-on-read flexibility, dynamic structure handling, and metadata pruning on nested fields.

### Q25: How does Snowflake optimize nested queries?  
**Answer:**  
By pruning micro-partitions based on path metadata (e.g., nested attributes).

### Q26: Does semi-structured data impact performance?  
**Answer:**  
Yes. Deeply nested structures may require more compute for traversal unless flattened or materialized.

---

# 5. External Functions & Integrations

### Q27: What are External Functions?  
**Answer:**  
Functions that call external APIs during query execution, enabling real-time enrichment.

### Q28: Why use External Functions?  
**Answer:**  
To integrate machine learning models, external data services, validation tools, or proprietary APIs.

### Q29: Are External Functions synchronous or asynchronous?  
**Answer:**  
They operate synchronously within the query but Snowflake manages scaling at the proxy layer.

### Q30: What integrations does Snowflake support?  
**Answer:**  
- Snowpark  
- Kafka and streaming services  
- External functions (API gateways)  
- BI tools  
- Data pipelines and ETL tools  

---

# 6. Snowflake Marketplace & Data Exchange

### Q31: What is Snowflake Marketplace?  
**Answer:**  
A platform to share or acquire datasets, services, and applications from third parties.

### Q32: What is Data Exchange?  
**Answer:**  
Private or public group-based sharing environments for governed collaboration.

### Q33: What is Zero-Copy Sharing?  
**Answer:**  
Sharing data without copying or duplicating it, meaning no additional storage cost for consumers.

### Q34: Why is Marketplace beneficial?  
**Answer:**  
Accelerates onboarding of third-party data and integrations with minimal engineering effort.

---

# 7. Scenarios

### Q35: Scenario — Build an incremental ingestion pipeline.  
**Answer:**  
Use Streams to capture CDC changes and Tasks to automate transformation and merge workflows. Incremental models reduce cost and latency.

### Q36: Scenario — Optimize semi-structured data in dashboards.  
**Answer:**  
Flatten frequently used fields, create MVs for pre-processed views, and consider clustering or search optimization for high-cardinality attributes.

### Q37: Scenario — High-frequency joins cause performance issues.  
**Answer:**  
Materialize the result using an MV or redesign the schema to reduce join complexity.

### Q38: Scenario — Need real-time enrichment using external ML APIs.  
**Answer:**  
Use External Functions with an API gateway. For cost-sensitive workloads, cache results or precompute batch predictions.

### Q39: Scenario — Business wants to distribute data to multiple partners.  
**Answer:**  
Use secure sharing through Data Exchange or Marketplace. No copy, no replication overhead for consumers.

### Q40: Scenario — Frequently changing schema for semi-structured data.  
**Answer:**  
Use VARIANT with schema-on-read. Materialize stable attributes into dedicated columns for performance.

---

# 8. Tradeoffs

### Q41: Tradeoff — Streams vs re-reading full tables  
Streams are efficient for large datasets but require metadata retention. Full-table scans are simpler but prohibitively expensive at scale.

### Q42: Tradeoff — Materialized Views vs Base Table Queries  
MVs reduce runtime for complex queries but add maintenance overhead and refresh cost.

### Q43: Tradeoff — Search Optimization vs Clustering Keys  
SOS accelerates selective queries but is more expensive. Clustering is cheaper but requires maintenance.

### Q44: Tradeoff — External Functions vs Batch Enrichment  
External functions provide real-time enrichment but can be slow or costly compared to batch or cached enrichment.

### Q45: Tradeoff — VARIANT vs Relational Columns  
VARIANT offers flexibility but has slower query performance for deeply nested paths.

---

# 9. Cost Considerations

### Q46: Cost of Streams  
No direct charge for streams, but long-lived streams increase metadata storage.

### Q47: Cost of Tasks  
Tasks consume warehouse compute whenever they run.

### Q48: Cost of Search Optimization  
Search indexes increase storage and require background maintenance.

### Q49: Cost of Materialized Views  
Incremental refresh operations generate compute overhead in the background.

### Q50: Cost of External Functions  
Invocation cost is tied to data transfer and external compute; excessive calls can become expensive.

### Q51: Cost of Marketplace usage  
Data providers may charge subscription fees; consumers incur compute cost to query shared data.

---

# 10. Best Practices

### Q52: Use Streams for true CDC instead of full refresh  
Minimizes compute cost and supports low-latency ETL.

### Q53: Prefer Tasks with dependency chaining  
Allows end-to-end pipeline orchestration without external schedulers.

### Q54: Flatten semi-structured fields accessed frequently  
Reduces repeated parsing and boosts performance.

### Q55: Use Materialized Views for expensive computed fields  
Ideal for dashboards, especially with aggregations or flattening logic.

### Q56: Use Search Optimization to accelerate highly selective predicates  
Especially useful when clustering cannot effectively organize sparse data.

### Q57: Cache or batch external function calls  
Reduces latency and cost.

### Q58: Use Marketplace for enrichment datasets instead of internal ETL pipelines  
Saves engineering time and enables faster insights.

### Q59: Audit dependency graphs for Streams & Tasks  
Prevents cyclic dependencies and unidentified failures.

### Q60: Apply governance for external integrations  
Ensure API security, throttling rules, and access controls.

---

# End of Category 10  
Fully expanded, detailed, GitHub-ready reference for Advanced Features & Miscellaneous.

